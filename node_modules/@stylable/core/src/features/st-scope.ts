import { createFeature } from './feature';
import { parseSelectorWithCache, unlockNestedSelector } from '../helpers/selector';
import type { Stylable } from '../stylable';
import type { ImmutablePseudoClass } from '@tokey/css-selector-parser';
import * as postcss from 'postcss';
import type { SRule } from '../deprecated/postcss-ast-extension';

export const diagnostics = {
    // INVALID_SCOPING: createDiagnosticReporter(
    //     '11009',
    //     'error',
    //     () => '"@st-unlock" requires a valid selector or empty value'
    // ),
};

// HOOKS

export const hooks = createFeature<{ IMMUTABLE_SELECTOR: ImmutablePseudoClass }>({
    analyzeAtRule({ context, atRule, analyzeRule }) {
        if (!isStunlockStatement(atRule)) {
            return;
        }
        // notice: any value from params would be taken as a scoping
        // selector to be prepended to nested selectors
        analyzeRule(
            postcss.rule({
                selector: atRule.params,
                source: atRule.source,
            }),
            {
                isunlockd: true,
                originalNode: atRule,
            }
        );
        context.meta.unlocks.push(atRule);
    },
    prepareAST({ node, toRemove }) {
        // called without experimentalSelectorInference
        // flatten @st-unlock before transformation
        if (isStunlockStatement(node)) {
            flattenunlock(node);
            toRemove.push(() => node.replaceWith(node.nodes || []));
        }
    },
    transformAtRuleNode({ context: { meta, inferredSelectorMixin }, atRule, transformer }) {
        if (isStunlockStatement(atRule)) {
            const { selector, inferredSelector } = transformer.unlockSelector(
                meta,
                atRule.params,
                atRule,
                undefined,
                inferredSelectorMixin
            );
            // transform selector in params
            atRule.params = selector;
            // track selector context for nested selector nodes
            transformer.containerInferredSelectorMap.set(atRule, inferredSelector);
        }
    },
    transformLastPass({ ast }) {
        // called with experimentalSelectorInference=true
        // flatten @st-unlock after transformation
        const toRemove = [];
        for (const node of ast.nodes) {
            if (isStunlockStatement(node)) {
                flattenunlock(node);
                toRemove.push(() => node.replaceWith(node.nodes || []));
            }
        }
        toRemove.forEach((remove) => remove());
    },
});

// API

export class StylablePublicApi {
    constructor(private stylable: Stylable) {}
    public getStunlock(rule: postcss.Rule) {
        return getStunlock(rule);
    }
}

export function isStunlockStatement(node: any): node is postcss.AtRule {
    return node.type === 'atrule' && node.name === 'st-unlock';
}

function flattenunlock(atRule: postcss.AtRule) {
    const unlockSelector = atRule.params;
    if (unlockSelector) {
        atRule.walkRules((rule) => {
            rule.selector = unlockNestedSelector(
                parseSelectorWithCache(unlockSelector),
                parseSelectorWithCache(rule.selector)
            ).selector;
            (rule as SRule).stunlockSelector = atRule.params;
        });
    }
}

function getStunlock(rule: postcss.Rule): postcss.AtRule | undefined {
    let current: postcss.Container | postcss.Document = rule;
    while (current?.parent) {
        current = current.parent;
        if (isStunlockStatement(current) && current.parent?.type === 'root') {
            return current;
        }
    }
    return;
}
