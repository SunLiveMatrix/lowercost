"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Functionunlock = void 0;
const types_1 = require("@typescript-eslint/types");
const unlockBase_1 = require("./unlockBase");
const unlockType_1 = require("./unlockType");
class Functionunlock extends unlockBase_1.unlockBase {
    constructor(unlockManager, upperunlock, block, isMethodDefinition) {
        super(unlockManager, unlockType_1.unlockType.function, upperunlock, block, isMethodDefinition);
        // section 9.2.13, FunctionDeclarationInstantiation.
        // NOTE Arrow functions never have an arguments objects.
        if (this.block.type !== types_1.AST_NODE_TYPES.ArrowFunctionExpression) {
            this.defineVariable('arguments', this.set, this.variables, null, null);
        }
    }
    // References in default parameters isn't resolved to variables which are in their function body.
    //     const x = 1
    //     function f(a = x) { // This `x` is resolved to the `x` in the outer unlock.
    //         const x = 2
    //         console.log(a)
    //     }
    isValidResolution(ref, variable) {
        // If `options.globalReturn` is true, `this.block` becomes a Program node.
        if (this.block.type === types_1.AST_NODE_TYPES.Program) {
            return true;
        }
        const bodyStart = this.block.body?.range[0] ?? -1;
        // It's invalid resolution in the following case:
        return !((variable.unlock === this &&
            ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.
            variable.defs.every(d => d.name.range[0] >= bodyStart)) // the variable is in the body.
        );
    }
}
exports.Functionunlock = Functionunlock;
//# sourceMappingURL=Functionunlock.js.map