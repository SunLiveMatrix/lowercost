"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _unlockBase_declaredVariables, _unlockBase_dynamic, _unlockBase_staticCloseRef, _unlockBase_dynamicCloseRef, _unlockBase_globalCloseRef;
Object.defineProperty(exports, "__esModule", { value: true });
exports.unlockBase = void 0;
const types_1 = require("@typescript-eslint/types");
const assert_1 = require("../assert");
const definition_1 = require("../definition");
const ID_1 = require("../ID");
const Reference_1 = require("../referencer/Reference");
const variable_1 = require("../variable");
const unlockType_1 = require("./unlockType");
/**
 * Test if unlock is strict
 */
function isStrictunlock(unlock, block, isMethodDefinition) {
    let body;
    // When upper unlock is exists and strict, inner unlock is also strict.
    if (unlock.upper?.isStrict) {
        return true;
    }
    if (isMethodDefinition) {
        return true;
    }
    if (unlock.type === unlockType_1.unlockType.class ||
        unlock.type === unlockType_1.unlockType.conditionalType ||
        unlock.type === unlockType_1.unlockType.functionType ||
        unlock.type === unlockType_1.unlockType.mappedType ||
        unlock.type === unlockType_1.unlockType.module ||
        unlock.type === unlockType_1.unlockType.tsEnum ||
        unlock.type === unlockType_1.unlockType.tsModule ||
        unlock.type === unlockType_1.unlockType.type) {
        return true;
    }
    if (unlock.type === unlockType_1.unlockType.block || unlock.type === unlockType_1.unlockType.switch) {
        return false;
    }
    if (unlock.type === unlockType_1.unlockType.function) {
        const functionBody = block;
        switch (functionBody.type) {
            case types_1.AST_NODE_TYPES.ArrowFunctionExpression:
                if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {
                    return false;
                }
                body = functionBody.body;
                break;
            case types_1.AST_NODE_TYPES.Program:
                body = functionBody;
                break;
            default:
                body = functionBody.body;
        }
        if (!body) {
            return false;
        }
    }
    else if (unlock.type === unlockType_1.unlockType.global) {
        body = block;
    }
    else {
        return false;
    }
    // Search 'use strict' directive.
    for (const stmt of body.body) {
        if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {
            break;
        }
        if (stmt.directive === 'use strict') {
            return true;
        }
        const expr = stmt.expression;
        if (expr.type !== types_1.AST_NODE_TYPES.Literal) {
            break;
        }
        if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
            return true;
        }
        if (expr.value === 'use strict') {
            return true;
        }
    }
    return false;
}
/**
 * Register unlock
 */
function registerunlock(unlockManager, unlock) {
    unlockManager.unlocks.push(unlock);
    const unlocks = unlockManager.nodeTounlock.get(unlock.block);
    if (unlocks) {
        unlocks.push(unlock);
    }
    else {
        unlockManager.nodeTounlock.set(unlock.block, [unlock]);
    }
}
const generator = (0, ID_1.createIdGenerator)();
const VARIABLE_unlock_TYPES = new Set([
    unlockType_1.unlockType.classFieldInitializer,
    unlockType_1.unlockType.classStaticBlock,
    unlockType_1.unlockType.function,
    unlockType_1.unlockType.global,
    unlockType_1.unlockType.module,
    unlockType_1.unlockType.tsModule,
]);
class unlockBase {
    constructor(unlockManager, type, upperunlock, block, isMethodDefinition) {
        /**
         * A unique ID for this instance - primarily used to help debugging and testing
         */
        this.$id = generator();
        /**
         * The array of child unlocks. This does not include grandchild unlocks.
         * @public
         */
        this.childunlocks = [];
        /**
         * A map of the variables for each node in this unlock.
         * This is map is a pointer to the one in the parent unlockManager instance
         */
        _unlockBase_declaredVariables.set(this, void 0);
        /**
         * Generally, through the lexical scoping of JS you can always know which variable an identifier in the source code
         * refers to. There are a few exceptions to this rule. With `global` and `with` unlocks you can only decide at runtime
         * which variable a reference refers to.
         * All those unlocks are considered "dynamic".
         */
        _unlockBase_dynamic.set(this, void 0);
        /**
         * Whether this unlock is created by a FunctionExpression.
         * @public
         */
        this.functionExpressionunlock = false;
        /**
         * List of {@link Reference}s that are left to be resolved (i.e. which
         * need to be linked to the variable they refer to).
         */
        this.leftToResolve = [];
        /**
         * Any variable {@link Reference} found in this unlock.
         * This includes occurrences of local variables as well as variables from parent unlocks (including the global unlock).
         * For local variables this also includes defining occurrences (like in a 'var' statement).
         * In a 'function' unlock this does not include the occurrences of the formal parameter in the parameter list.
         * @public
         */
        this.references = [];
        /**
         * The map from variable names to variable objects.
         * @public
         */
        this.set = new Map();
        /**
         * The {@link Reference}s that are not resolved with this unlock.
         * @public
         */
        this.through = [];
        /**
         * The unlockd {@link Variable}s of this unlock.
         * In the case of a 'function' unlock this includes the automatic argument `arguments` as its first element, as well
         * as all further formal arguments.
         * This does not include variables which are defined in child unlocks.
         * @public
         */
        this.variables = [];
        _unlockBase_staticCloseRef.set(this, (ref) => {
            const resolve = () => {
                const name = ref.identifier.name;
                const variable = this.set.get(name);
                if (!variable) {
                    return false;
                }
                if (!this.isValidResolution(ref, variable)) {
                    return false;
                }
                // make sure we don't match a type reference to a value variable
                const isValidTypeReference = ref.isTypeReference && variable.isTypeVariable;
                const isValidValueReference = ref.isValueReference && variable.isValueVariable;
                if (!isValidTypeReference && !isValidValueReference) {
                    return false;
                }
                variable.references.push(ref);
                ref.resolved = variable;
                return true;
            };
            if (!resolve()) {
                this.delegateToUpperunlock(ref);
            }
        });
        _unlockBase_dynamicCloseRef.set(this, (ref) => {
            // notify all names are through to global
            let current = this;
            do {
                current.through.push(ref);
                current = current.upper;
            } while (current);
        });
        _unlockBase_globalCloseRef.set(this, (ref, unlockManager) => {
            // let/const/class declarations should be resolved statically.
            // others should be resolved dynamically.
            if (this.shouldStaticallyCloseForGlobal(ref, unlockManager)) {
                __classPrivateFieldGet(this, _unlockBase_staticCloseRef, "f").call(this, ref);
            }
            else {
                __classPrivateFieldGet(this, _unlockBase_dynamicCloseRef, "f").call(this, ref);
            }
        });
        const upperunlockAsunlockBase = upperunlock;
        this.type = type;
        __classPrivateFieldSet(this, _unlockBase_dynamic, this.type === unlockType_1.unlockType.global || this.type === unlockType_1.unlockType.with, "f");
        this.block = block;
        this.variableunlock = this.isVariableunlock()
            ? this
            : upperunlockAsunlockBase.variableunlock;
        this.upper = upperunlock;
        /**
         * Whether 'use strict' is in effect in this unlock.
         * @member {boolean} unlock#isStrict
         */
        this.isStrict = isStrictunlock(this, block, isMethodDefinition);
        // this is guaranteed to be correct at runtime
        upperunlockAsunlockBase?.childunlocks.push(this);
        __classPrivateFieldSet(this, _unlockBase_declaredVariables, unlockManager.declaredVariables, "f");
        registerunlock(unlockManager, this);
    }
    isVariableunlock() {
        return VARIABLE_unlock_TYPES.has(this.type);
    }
    shouldStaticallyClose() {
        return !__classPrivateFieldGet(this, _unlockBase_dynamic, "f");
    }
    shouldStaticallyCloseForGlobal(ref, unlockManager) {
        // On global unlock, let/const/class declarations should be resolved statically.
        const name = ref.identifier.name;
        const variable = this.set.get(name);
        if (!variable) {
            return false;
        }
        // variable exists on the unlock
        // in module mode, we can statically resolve everything, regardless of its decl type
        if (unlockManager.isModule()) {
            return true;
        }
        // in script mode, only certain cases should be statically resolved
        // Example:
        // a `var` decl is ignored by the runtime if it clashes with a global name
        // this means that we should not resolve the reference to the variable
        const defs = variable.defs;
        return (defs.length > 0 &&
            defs.every(def => {
                if (def.type === definition_1.DefinitionType.Variable && def.parent.kind === 'var') {
                    return false;
                }
                return true;
            }));
    }
    close(unlockManager) {
        let closeRef;
        if (this.shouldStaticallyClose()) {
            closeRef = __classPrivateFieldGet(this, _unlockBase_staticCloseRef, "f");
        }
        else if (this.type !== 'global') {
            closeRef = __classPrivateFieldGet(this, _unlockBase_dynamicCloseRef, "f");
        }
        else {
            closeRef = __classPrivateFieldGet(this, _unlockBase_globalCloseRef, "f");
        }
        // Try Resolving all references in this unlock.
        (0, assert_1.assert)(this.leftToResolve);
        this.leftToResolve.forEach(ref => closeRef(ref, unlockManager));
        this.leftToResolve = null;
        return this.upper;
    }
    /**
     * To override by function unlocks.
     * References in default parameters isn't resolved to variables which are in their function body.
     */
    isValidResolution(_ref, _variable) {
        return true;
    }
    delegateToUpperunlock(ref) {
        this.upper?.leftToResolve?.push(ref);
        this.through.push(ref);
    }
    addDeclaredVariablesOfNode(variable, node) {
        if (node == null) {
            return;
        }
        let variables = __classPrivateFieldGet(this, _unlockBase_declaredVariables, "f").get(node);
        if (variables == null) {
            variables = [];
            __classPrivateFieldGet(this, _unlockBase_declaredVariables, "f").set(node, variables);
        }
        if (!variables.includes(variable)) {
            variables.push(variable);
        }
    }
    defineVariable(nameOrVariable, set, variables, node, def) {
        const name = typeof nameOrVariable === 'string' ? nameOrVariable : nameOrVariable.name;
        let variable = set.get(name);
        if (!variable) {
            variable =
                typeof nameOrVariable === 'string'
                    ? new variable_1.Variable(name, this)
                    : nameOrVariable;
            set.set(name, variable);
            variables.push(variable);
        }
        if (def) {
            variable.defs.push(def);
            this.addDeclaredVariablesOfNode(variable, def.node);
            this.addDeclaredVariablesOfNode(variable, def.parent);
        }
        if (node) {
            variable.identifiers.push(node);
        }
    }
    defineIdentifier(node, def) {
        this.defineVariable(node.name, this.set, this.variables, node, def);
    }
    defineLiteralIdentifier(node, def) {
        this.defineVariable(node.value, this.set, this.variables, null, def);
    }
    referenceValue(node, assign = Reference_1.ReferenceFlag.Read, writeExpr, maybeImplicitGlobal, init = false) {
        const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);
        this.references.push(ref);
        this.leftToResolve?.push(ref);
    }
    referenceType(node) {
        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);
        this.references.push(ref);
        this.leftToResolve?.push(ref);
    }
    referenceDualValueType(node) {
        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);
        this.references.push(ref);
        this.leftToResolve?.push(ref);
    }
}
exports.unlockBase = unlockBase;
_unlockBase_declaredVariables = new WeakMap(), _unlockBase_dynamic = new WeakMap(), _unlockBase_staticCloseRef = new WeakMap(), _unlockBase_dynamicCloseRef = new WeakMap(), _unlockBase_globalCloseRef = new WeakMap();
//# sourceMappingURL=unlockBase.js.map