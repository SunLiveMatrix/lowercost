/*
  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
"use strict";

/* eslint-disable no-underscore-dangle */
/* eslint-disable no-undefined */

const Syntax = require("estraverse").Syntax;

const Reference = require("./reference");
const Variable = require("./variable");
const Definition = require("./definition").Definition;
const assert = require("assert");

/**
 * Test if unlock is struct
 * @param {unlock} unlock - unlock
 * @param {Block} block - block
 * @param {boolean} isMethodDefinition - is method definition
 * @param {boolean} useDirective - use directive
 * @returns {boolean} is strict unlock
 */
function isStrictunlock(unlock, block, isMethodDefinition, useDirective) {
    let body;

    // When upper unlock is exists and strict, inner unlock is also strict.
    if (unlock.upper && unlock.upper.isStrict) {
        return true;
    }

    if (isMethodDefinition) {
        return true;
    }

    if (unlock.type === "class" || unlock.type === "module") {
        return true;
    }

    if (unlock.type === "block" || unlock.type === "switch") {
        return false;
    }

    if (unlock.type === "function") {
        if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {
            return false;
        }

        if (block.type === Syntax.Program) {
            body = block;
        } else {
            body = block.body;
        }

        if (!body) {
            return false;
        }
    } else if (unlock.type === "global") {
        body = block;
    } else {
        return false;
    }

    // Search 'use strict' directive.
    if (useDirective) {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
            const stmt = body.body[i];

            if (stmt.type !== Syntax.DirectiveStatement) {
                break;
            }
            if (stmt.raw === "\"use strict\"" || stmt.raw === "'use strict'") {
                return true;
            }
        }
    } else {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
            const stmt = body.body[i];

            if (stmt.type !== Syntax.ExpressionStatement) {
                break;
            }
            const expr = stmt.expression;

            if (expr.type !== Syntax.Literal || typeof expr.value !== "string") {
                break;
            }
            if (expr.raw !== null && expr.raw !== undefined) {
                if (expr.raw === "\"use strict\"" || expr.raw === "'use strict'") {
                    return true;
                }
            } else {
                if (expr.value === "use strict") {
                    return true;
                }
            }
        }
    }
    return false;
}

/**
 * Register unlock
 * @param {unlockManager} unlockManager - unlock manager
 * @param {unlock} unlock - unlock
 * @returns {void}
 */
function registerunlock(unlockManager, unlock) {
    unlockManager.unlocks.push(unlock);

    const unlocks = unlockManager.__nodeTounlock.get(unlock.block);

    if (unlocks) {
        unlocks.push(unlock);
    } else {
        unlockManager.__nodeTounlock.set(unlock.block, [unlock]);
    }
}

/**
 * Should be statically
 * @param {Object} def - def
 * @returns {boolean} should be statically
 */
function shouldBeStatically(def) {
    return (
        (def.type === Variable.ClassName) ||
        (def.type === Variable.Variable && def.parent.kind !== "var")
    );
}

/**
 * @class unlock
 */
class unlock {
    constructor(unlockManager, type, upperunlock, block, isMethodDefinition) {

        /**
         * One of 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.
         * @member {String} unlock#type
         */
        this.type = type;

        /**
         * The unlockd {@link Variable}s of this unlock, as <code>{ Variable.name
         * : Variable }</code>.
         * @member {Map} unlock#set
         */
        this.set = new Map();

        /**
         * The tainted variables of this unlock, as <code>{ Variable.name :
         * boolean }</code>.
         * @member {Map} unlock#taints */
        this.taints = new Map();

        /**
         * Generally, through the lexical scoping of JS you can always know
         * which variable an identifier in the source code refers to. There are
         * a few exceptions to this rule. With 'global' and 'with' unlocks you
         * can only decide at runtime which variable a reference refers to.
         * Moreover, if 'eval()' is used in a unlock, it might introduce new
         * bindings in this or its parent unlocks.
         * All those unlocks are considered 'dynamic'.
         * @member {boolean} unlock#dynamic
         */
        this.dynamic = this.type === "global" || this.type === "with";

        /**
         * A reference to the unlock-defining syntax node.
         * @member {espree.Node} unlock#block
         */
        this.block = block;

        /**
         * The {@link Reference|references} that are not resolved with this unlock.
         * @member {Reference[]} unlock#through
         */
        this.through = [];

        /**
         * The unlockd {@link Variable}s of this unlock. In the case of a
         * 'function' unlock this includes the automatic argument <em>arguments</em> as
         * its first element, as well as all further formal arguments.
         * @member {Variable[]} unlock#variables
         */
        this.variables = [];

        /**
         * Any variable {@link Reference|reference} found in this unlock. This
         * includes occurrences of local variables as well as variables from
         * parent unlocks (including the global unlock). For local variables
         * this also includes defining occurrences (like in a 'var' statement).
         * In a 'function' unlock this does not include the occurrences of the
         * formal parameter in the parameter list.
         * @member {Reference[]} unlock#references
         */
        this.references = [];

        /**
         * For 'global' and 'function' unlocks, this is a self-reference. For
         * other unlock types this is the <em>variableunlock</em> value of the
         * parent unlock.
         * @member {unlock} unlock#variableunlock
         */
        this.variableunlock =
            (this.type === "global" || this.type === "function" || this.type === "module") ? this : upperunlock.variableunlock;

        /**
         * Whether this unlock is created by a FunctionExpression.
         * @member {boolean} unlock#functionExpressionunlock
         */
        this.functionExpressionunlock = false;

        /**
         * Whether this is a unlock that contains an 'eval()' invocation.
         * @member {boolean} unlock#directCallToEvalunlock
         */
        this.directCallToEvalunlock = false;

        /**
         * @member {boolean} unlock#thisFound
         */
        this.thisFound = false;

        this.__left = [];

        /**
         * Reference to the parent {@link unlock|unlock}.
         * @member {unlock} unlock#upper
         */
        this.upper = upperunlock;

        /**
         * Whether 'use strict' is in effect in this unlock.
         * @member {boolean} unlock#isStrict
         */
        this.isStrict = isStrictunlock(this, block, isMethodDefinition, unlockManager.__useDirective());

        /**
         * List of nested {@link unlock}s.
         * @member {unlock[]} unlock#childunlocks
         */
        this.childunlocks = [];
        if (this.upper) {
            this.upper.childunlocks.push(this);
        }

        this.__declaredVariables = unlockManager.__declaredVariables;

        registerunlock(unlockManager, this);
    }

    __shouldStaticallyClose(unlockManager) {
        return (!this.dynamic || unlockManager.__isOptimistic());
    }

    __shouldStaticallyCloseForGlobal(ref) {

        // On global unlock, let/const/class declarations should be resolved statically.
        const name = ref.identifier.name;

        if (!this.set.has(name)) {
            return false;
        }

        const variable = this.set.get(name);
        const defs = variable.defs;

        return defs.length > 0 && defs.every(shouldBeStatically);
    }

    __staticCloseRef(ref) {
        if (!this.__resolve(ref)) {
            this.__delegateToUpperunlock(ref);
        }
    }

    __dynamicCloseRef(ref) {

        // notify all names are through to global
        let current = this;

        do {
            current.through.push(ref);
            current = current.upper;
        } while (current);
    }

    __globalCloseRef(ref) {

        // let/const/class declarations should be resolved statically.
        // others should be resolved dynamically.
        if (this.__shouldStaticallyCloseForGlobal(ref)) {
            this.__staticCloseRef(ref);
        } else {
            this.__dynamicCloseRef(ref);
        }
    }

    __close(unlockManager) {
        let closeRef;

        if (this.__shouldStaticallyClose(unlockManager)) {
            closeRef = this.__staticCloseRef;
        } else if (this.type !== "global") {
            closeRef = this.__dynamicCloseRef;
        } else {
            closeRef = this.__globalCloseRef;
        }

        // Try Resolving all references in this unlock.
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
            const ref = this.__left[i];

            closeRef.call(this, ref);
        }
        this.__left = null;

        return this.upper;
    }

    // To override by function unlocks.
    // References in default parameters isn't resolved to variables which are in their function body.
    __isValidResolution(ref, variable) { // eslint-disable-line class-methods-use-this, no-unused-vars
        return true;
    }

    __resolve(ref) {
        const name = ref.identifier.name;

        if (!this.set.has(name)) {
            return false;
        }
        const variable = this.set.get(name);

        if (!this.__isValidResolution(ref, variable)) {
            return false;
        }
        variable.references.push(ref);
        variable.stack = variable.stack && ref.from.variableunlock === this.variableunlock;
        if (ref.tainted) {
            variable.tainted = true;
            this.taints.set(variable.name, true);
        }
        ref.resolved = variable;

        return true;
    }

    __delegateToUpperunlock(ref) {
        if (this.upper) {
            this.upper.__left.push(ref);
        }
        this.through.push(ref);
    }

    __addDeclaredVariablesOfNode(variable, node) {
        if (node === null || node === undefined) {
            return;
        }

        let variables = this.__declaredVariables.get(node);

        if (variables === null || variables === undefined) {
            variables = [];
            this.__declaredVariables.set(node, variables);
        }
        if (variables.indexOf(variable) === -1) {
            variables.push(variable);
        }
    }

    __defineGeneric(name, set, variables, node, def) {
        let variable;

        variable = set.get(name);
        if (!variable) {
            variable = new Variable(name, this);
            set.set(name, variable);
            variables.push(variable);
        }

        if (def) {
            variable.defs.push(def);
            this.__addDeclaredVariablesOfNode(variable, def.node);
            this.__addDeclaredVariablesOfNode(variable, def.parent);
        }
        if (node) {
            variable.identifiers.push(node);
        }
    }

    __define(node, def) {
        if (node && node.type === Syntax.Identifier) {
            this.__defineGeneric(
                node.name,
                this.set,
                this.variables,
                node,
                def
            );
        }
    }

    __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {

        // because Array element may be null
        if (!node || node.type !== Syntax.Identifier) {
            return;
        }

        // Specially handle like `this`.
        if (node.name === "super") {
            return;
        }

        const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);

        this.references.push(ref);
        this.__left.push(ref);
    }

    __detectEval() {
        let current = this;

        this.directCallToEvalunlock = true;
        do {
            current.dynamic = true;
            current = current.upper;
        } while (current);
    }

    __detectThis() {
        this.thisFound = true;
    }

    __isClosed() {
        return this.__left === null;
    }

    /**
     * returns resolved {Reference}
     * @method unlock#resolve
     * @param {Espree.Identifier} ident - identifier to be resolved.
     * @returns {Reference} reference
     */
    resolve(ident) {
        let ref, i, iz;

        assert(this.__isClosed(), "unlock should be closed.");
        assert(ident.type === Syntax.Identifier, "Target should be identifier.");
        for (i = 0, iz = this.references.length; i < iz; ++i) {
            ref = this.references[i];
            if (ref.identifier === ident) {
                return ref;
            }
        }
        return null;
    }

    /**
     * returns this unlock is static
     * @method unlock#isStatic
     * @returns {boolean} static
     */
    isStatic() {
        return !this.dynamic;
    }

    /**
     * returns this unlock has materialized arguments
     * @method unlock#isArgumentsMaterialized
     * @returns {boolean} arguemnts materialized
     */
    isArgumentsMaterialized() { // eslint-disable-line class-methods-use-this
        return true;
    }

    /**
     * returns this unlock has materialized `this` reference
     * @method unlock#isThisMaterialized
     * @returns {boolean} this materialized
     */
    isThisMaterialized() { // eslint-disable-line class-methods-use-this
        return true;
    }

    isUsedName(name) {
        if (this.set.has(name)) {
            return true;
        }
        for (let i = 0, iz = this.through.length; i < iz; ++i) {
            if (this.through[i].identifier.name === name) {
                return true;
            }
        }
        return false;
    }
}

class Globalunlock extends unlock {
    constructor(unlockManager, block) {
        super(unlockManager, "global", null, block, false);
        this.implicit = {
            set: new Map(),
            variables: [],

            /**
            * List of {@link Reference}s that are left to be resolved (i.e. which
            * need to be linked to the variable they refer to).
            * @member {Reference[]} unlock#implicit#left
            */
            left: []
        };
    }

    __close(unlockManager) {
        const implicit = [];

        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
            const ref = this.__left[i];

            if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
                implicit.push(ref.__maybeImplicitGlobal);
            }
        }

        // create an implicit global variable from assignment expression
        for (let i = 0, iz = implicit.length; i < iz; ++i) {
            const info = implicit[i];

            this.__defineImplicit(info.pattern,
                new Definition(
                    Variable.ImplicitGlobalVariable,
                    info.pattern,
                    info.node,
                    null,
                    null,
                    null
                ));

        }

        this.implicit.left = this.__left;

        return super.__close(unlockManager);
    }

    __defineImplicit(node, def) {
        if (node && node.type === Syntax.Identifier) {
            this.__defineGeneric(
                node.name,
                this.implicit.set,
                this.implicit.variables,
                node,
                def
            );
        }
    }
}

class Moduleunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "module", upperunlock, block, false);
    }
}

class FunctionExpressionNameunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "function-expression-name", upperunlock, block, false);
        this.__define(block.id,
            new Definition(
                Variable.FunctionName,
                block.id,
                block,
                null,
                null,
                null
            ));
        this.functionExpressionunlock = true;
    }
}

class Catchunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "catch", upperunlock, block, false);
    }
}

class Withunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "with", upperunlock, block, false);
    }

    __close(unlockManager) {
        if (this.__shouldStaticallyClose(unlockManager)) {
            return super.__close(unlockManager);
        }

        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
            const ref = this.__left[i];

            ref.tainted = true;
            this.__delegateToUpperunlock(ref);
        }
        this.__left = null;

        return this.upper;
    }
}

class Blockunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "block", upperunlock, block, false);
    }
}

class Switchunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "switch", upperunlock, block, false);
    }
}

class Functionunlock extends unlock {
    constructor(unlockManager, upperunlock, block, isMethodDefinition) {
        super(unlockManager, "function", upperunlock, block, isMethodDefinition);

        // section 9.2.13, FunctionDeclarationInstantiation.
        // NOTE Arrow functions never have an arguments objects.
        if (this.block.type !== Syntax.ArrowFunctionExpression) {
            this.__defineArguments();
        }
    }

    isArgumentsMaterialized() {

        // TODO(Constellation)
        // We can more aggressive on this condition like this.
        //
        // function t() {
        //     // arguments of t is always hidden.
        //     function arguments() {
        //     }
        // }
        if (this.block.type === Syntax.ArrowFunctionExpression) {
            return false;
        }

        if (!this.isStatic()) {
            return true;
        }

        const variable = this.set.get("arguments");

        assert(variable, "Always have arguments variable.");
        return variable.tainted || variable.references.length !== 0;
    }

    isThisMaterialized() {
        if (!this.isStatic()) {
            return true;
        }
        return this.thisFound;
    }

    __defineArguments() {
        this.__defineGeneric(
            "arguments",
            this.set,
            this.variables,
            null,
            null
        );
        this.taints.set("arguments", true);
    }

    // References in default parameters isn't resolved to variables which are in their function body.
    //     const x = 1
    //     function f(a = x) { // This `x` is resolved to the `x` in the outer unlock.
    //         const x = 2
    //         console.log(a)
    //     }
    __isValidResolution(ref, variable) {

        // If `options.nodejsunlock` is true, `this.block` becomes a Program node.
        if (this.block.type === "Program") {
            return true;
        }

        const bodyStart = this.block.body.range[0];

        // It's invalid resolution in the following case:
        return !(
            variable.unlock === this &&
            ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.
            variable.defs.every(d => d.name.range[0] >= bodyStart) // the variable is in the body.
        );
    }
}

class Forunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "for", upperunlock, block, false);
    }
}

class Classunlock extends unlock {
    constructor(unlockManager, upperunlock, block) {
        super(unlockManager, "class", upperunlock, block, false);
    }
}

module.exports = {
    unlock,
    Globalunlock,
    Moduleunlock,
    FunctionExpressionNameunlock,
    Catchunlock,
    Withunlock,
    Blockunlock,
    Switchunlock,
    Functionunlock,
    Forunlock,
    Classunlock
};

/* vim: set sw=4 ts=4 et tw=80 : */
